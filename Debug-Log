I also tried to run the bundled tests to see what actually breaks. Below is an audit-style report of things that look wrong, brittle, or inconsistent, plus what to change.

I’ll group it so you can fix them in order.

1. Hard/Actual Breakages I Saw
1.1 test_date_branches.py runs on import and kills the process

File: MemoryMate-PhotoFlow-main/test_date_branches.py

This script immediately connects to reference_data.db, doesn’t find the table, prints an error, and does sys.exit(1).

When I ran pytest from the project root, this file was picked up and the whole run died because it’s not wrapped in if __name__ == "__main__":.

Why it’s a bug: any tool/test runner that discovers files named test_*.py will try to import it. Importing it currently executes it and exits.

Fix:

if __name__ == "__main__":
    # existing script body


Optionally move it into a scripts/ folder so pytest won’t see it.

1.2 Tests can’t be collected because of missing GUI deps

When I ran the tests under tests/, collection failed because services/__init__.py pulls in Qt/PySide6 things (like the thumbnail service) right at import time, and PySide6 isn’t installed in this environment.

Why it matters: the “pure business logic” tests (tests/test_metadata_service.py, tests/test_photo_scan_service.py, tests/test_repositories.py) should be runnable without a GUI stack. Right now they aren’t, because importing services cascades into Qt imports.

Minimal fix:
Make the GUI/Qt stuff optional in services/__init__.py:

# services/__init__.py
try:
    from .thumbnail_service import (
        ThumbnailService,
        LRUCache,
        get_thumbnail_service,
        install_qt_message_handler,
        PIL_PREFERRED_FORMATS,
    )
    _QT_AVAILABLE = True
except Exception:
    _QT_AVAILABLE = False


…and only export those names when Qt is available. That lets tests import the service layer in CI/headless environments.

2. Inconsistencies Around the Database

I found three different “ideas” of what the database is called:

reference_db.py → uses DB_FILE = "reference_data.db"

the repository layer (repository/base_repository.py) → default path is also "reference_data.db" (good)

but app_services.py defines DB_PATH = "photo_app.db" and then doesn’t actually use it anywhere meaningful

Why it’s a bug-ish thing: having “photo_app.db” defined but not used is confusing, and it’s easy to accidentally write code later that connects to the wrong file and you end up with two SQLite files side by side.

Fix choices:

EITHER delete the unused constant in app_services.py:

# app_services.py
# DB_PATH = "photo_app.db"  # ← remove this, source of confusion


OR, if "photo_app.db" was the new name, make all entry points (the repository DatabaseConnection and ReferenceDB) build the same absolute path to that file.

Right now it’s just inconsistent, so I’d clean it.

3. Test/Script Layout Issue

Besides test_date_branches.py, there are a couple of other “utility” scripts in the project root (test_open_images.py, test_tabs_debug.py, etc.). Most of them do have if __name__ == "__main__":, so they’re okay.

The odd one out is the date-branches script above. That’s the one that actually broke running tests. So the main actionable bug here is: root-level test script without __main__ guard.

4. Over-eager, Top-level Qt Imports

This is the pattern:

GUI modules obviously need PySide6 (e.g. main_qt.py, main_window_qt.py, thumbnail_grid_qt.py) — that’s fine.

But modules that look like pure services (the whole services/ package) also pull in Qt things because the thumbnail code and the “suppress TIFF warnings” code live there (services/thumbnail_service.py) and are re-exported from services/__init__.py.

Why that’s a problem: anything that just wants to do “scan my photos” in a console environment will hit an ImportError: No module named 'PySide6' just by importing services.

What to do:

Make the imports in services/__init__.py lazy/optional (shown above).

Or split GUI/Qt helpers into a submodule, e.g. services.qt_helpers, and don’t import that at package import time.

That’s not a logical bug in your app flow, but it is a packaging/import bug that will bite you in CI or headless runs.

5. Database-expecting Scripts With No Guard

You also have utility/migration files like:

migrate_add_video_tables.py

migrate_tags_add_project_id.py

normalize_existing_paths.py

These all assume the DB exists and has your schema. That’s normal for scripts — but they also live at the project top level and are named in a way that some tools may try to import them. They don’t have if __name__ == "__main__": guards, so importing them could run top-level code (or at least create connections) unexpectedly.

Best practice fix: wrap entry logic in if __name__ == "__main__": for every standalone script in the root.

6. Things I Checked That Look Okay

I poked the parts that usually hide sneaky errors:

repository/ (base repo, photo repo, folder repo, project repo) — structurally consistent and uses the shared DatabaseConnection. The schema/migration story looks intentional.

services/metadata_service.py — long, but the public methods (extract_metadata, extract_basic_metadata) are shaped fine.

services/photo_scan_service.py — a lot of defensive code (timeouts, skip system folders). The “BUG FIX #7” comments you left in there look already applied, not pending.

services/thumbnail_service.py — contains the install_qt_message_handler the app uses; looks fine.

So the biggest immediate bugs are the import-time script that exits, and the service package pulling in GUI stuff unconditionally.
