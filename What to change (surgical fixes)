What to change (surgical fixes)
A) Make videos appear in date view immediately (fallback on mtime)

File: services/video_service.py
Method: index_video(...)

Right after you compute or receive modified, set fallback created fields from it so the date hierarchy can use them right away:

# add near insert payload in index_video
created_ts = None
created_date = None
created_year = None
if modified:
    # modified is "YYYY-MM-DD HH:MM:SS"
    try:
        date_str = modified.split(' ')[0]  # YYYY-MM-DD
        from datetime import datetime
        dt = datetime.strptime(date_str, '%Y-%m-%d')
        created_ts = int(dt.timestamp())
        created_date = date_str
        created_year = dt.year
    except Exception:
        pass

video_id = self._video_repo.create(
    path=path,
    folder_id=folder_id,
    project_id=project_id,
    size_kb=size_kb,
    modified=modified,
    created_ts=created_ts,
    created_date=created_date,
    created_year=created_year,
    metadata_status='pending',
    thumbnail_status='pending'
)


This keeps behavior consistent with photos: you get a usable date immediately; later the worker can refine date_taken and (if needed) adjust created_*.

(You already do this refinement in workers/video_metadata_worker.py: good.)

B) Count APIs: add combined media counters and use them in the UI

File: reference_db.py

Add new helpers that include photos + videos:

def count_media_for_year(self, year: int | str, project_id: int | None = None) -> int:
    y = str(year)
    with self._connect() as conn:
        cur = conn.cursor()
        if project_id is not None:
            cur.execute("""
                SELECT
                  (SELECT COUNT(*) FROM photo_metadata WHERE project_id=? AND created_date LIKE ? || '-%')
                + (SELECT COUNT(*) FROM video_metadata WHERE project_id=? AND created_date LIKE ? || '-%')
            """, (project_id, y, project_id, y))
        else:
            cur.execute("""
                SELECT
                  (SELECT COUNT(*) FROM photo_metadata WHERE created_date LIKE ? || '-%')
                + (SELECT COUNT(*) FROM video_metadata WHERE created_date LIKE ? || '-%')
            """, (y, y))
        return int(cur.fetchone()[0] or 0)

def count_media_for_month(self, year: int | str, month: int | str, project_id: int | None = None) -> int:
    y = str(year); m = f"{int(month):02d}" if str(month).isdigit() else str(month)
    ym = f"{y}-{m}"
    with self._connect() as conn:
        cur = conn.cursor()
        if project_id is not None:
            cur.execute("""
                SELECT
                  (SELECT COUNT(*) FROM photo_metadata WHERE project_id=? AND created_date LIKE ? || '-%')
                + (SELECT COUNT(*) FROM video_metadata WHERE project_id=? AND created_date LIKE ? || '-%')
            """, (project_id, ym, project_id, ym))
        else:
            cur.execute("""
                SELECT
                  (SELECT COUNT(*) FROM photo_metadata WHERE created_date LIKE ? || '-%')
                + (SELECT COUNT(*) FROM video_metadata WHERE created_date LIKE ? || '-%')
            """, (ym, ym))
        return int(cur.fetchone()[0] or 0)

def count_media_for_day(self, yyyymmdd: str, project_id: int | None = None) -> int:
    with self._connect() as conn:
        cur = conn.cursor()
        if project_id is not None:
            cur.execute("""
                SELECT
                  (SELECT COUNT(*) FROM photo_metadata WHERE project_id=? AND created_date = ?)
                + (SELECT COUNT(*) FROM video_metadata WHERE project_id=? AND created_date = ?)
            """, (project_id, yyyymmdd, project_id, yyyymmdd))
        else:
            cur.execute("""
                SELECT
                  (SELECT COUNT(*) FROM photo_metadata WHERE created_date = ?)
                + (SELECT COUNT(*) FROM video_metadata WHERE created_date = ?)
            """, (yyyymmdd, yyyymmdd))
        return int(cur.fetchone()[0] or 0)


File: sidebar_qt.py
Switch the date label counts to use combined APIs (count_media_for_*) instead of photo-only. You already guard against missing methods; keep that pattern:

# year_count = self.db.count_for_year(year)  # old
year_count = self.db.count_media_for_year(year, current_project_id)
# Similarly for months/days


This immediately fixes ‚Äúcounts don‚Äôt match what I see,‚Äù especially once C) is in place.

C) Opening a date node should load both photos and videos

File: reference_db.py ‚Äî add getters for videos and a combined getter:

def get_videos_by_date(self, ymd: str, project_id: int | None = None) -> list[str]:
    with self._connect() as conn:
        if project_id is not None:
            cur = conn.execute("""
                SELECT path FROM video_metadata
                WHERE created_date = ? AND project_id = ?
                ORDER BY created_ts ASC, path ASC
            """, (ymd, project_id))
        else:
            cur = conn.execute("""
                SELECT path FROM video_metadata
                WHERE created_date = ?
                ORDER BY created_ts ASC, path ASC
            """, (ymd,))
        return [r[0] for r in cur.fetchall()]

def get_media_by_date(self, ymd: str, project_id: int | None = None) -> list[str]:
    photos = self.get_images_by_date(ymd, project_id)
    videos = self.get_videos_by_date(ymd, project_id)
    # Option A (simple): return photos + videos (grid already detects videos)
    return photos + videos
    # Option B (strict order): fetch created_ts + path and sort in Python if you expose created_ts


File: main_window_qt.py (the slot that opens ‚Äúby_date:*‚Äù)
Replace:

paths = db.get_images_by_date(date_key)


with:

paths = db.get_media_by_date(date_key, current_project_id)


Your thumbnail_grid_qt.py already differentiates with is_video_file(path), so the grid will render appropriately.

D) Build (or stop building) branches for videos

You have project_videos but build_date_branches() populates only project_images.

Choose one strategy:

Preferred (simpler): stop relying on branch tables for ‚ÄúBy Date‚Äù. You already have fast indices (idx_photo_metadata_project_date and idx_video_metadata_project_date). Use the on-demand queries above rather than branch tables. (Leave branches for user-made logical groupings.)

If you must keep branches: extend build_date_branches() to also fill project_videos:

# After inserting image paths for a given date d
cur.execute("""
    INSERT OR IGNORE INTO project_videos (project_id, branch_key, video_path)
    SELECT ?, ?, vm.path
    FROM video_metadata vm
    WHERE vm.project_id = ? AND vm.created_date = ?
""", (project_id, f"by_date:{d}", project_id, d))


‚Ä¶and add a count_videos_by_branch(project_id, branch_key) mirror to count_images_by_branch if the UI uses counts from branch tables anywhere.

E) Backfill both media types after scan (one pass)

File: reference_db.py

Mirror single_pass_backfill_created_fields() for video_metadata, or unify it:

def single_pass_backfill_created_fields_videos(self, chunk_size: int = 1000) -> int:
    # copy of photo version, but working on video_metadata


File: main_window_qt.py (after scanning)
Call both:

backfilled_photos = db.single_pass_backfill_created_fields()
backfilled_videos = db.single_pass_backfill_created_fields_videos()


That way the ‚ÄúBy Date‚Äù tree is reliable even if the ffprobe worker hasn‚Äôt completed.

Keep your existing ffprobe path ‚Äî it will improve accuracy (date_taken) later, but your UI is already usable from the fallback.

F) Date hierarchy source should be union of photos + videos

If you use a precomputed hierarchy, update it; otherwise, compute distinct years/months/days by union:

-- Distinct years
SELECT DISTINCT created_year FROM photo_metadata WHERE project_id=?
UNION
SELECT DISTINCT created_year FROM video_metadata WHERE project_id=?
ORDER BY 1 DESC;

-- Distinct year-months
SELECT DISTINCT substr(created_date, 1, 7) FROM photo_metadata WHERE project_id=?
UNION
SELECT DISTINCT substr(created_date, 1, 7) FROM video_metadata WHERE project_id=?
ORDER BY 1 DESC;

-- Distinct days
SELECT DISTINCT created_date FROM photo_metadata WHERE project_id=?
UNION
SELECT DISTINCT created_date FROM video_metadata WHERE project_id=?
ORDER BY 1 DESC;


This ensures the tree has a branch for a day that contains only videos (no photos).

Edge cases & polish

Missing or malformed dates: your worker already guards parsing. In counts/getters, rely on created_date only; don‚Äôt try to infer on the fly there ‚Äî that‚Äôs the job of the fallback at index-time (A) and backfill (E).

Performance: You‚Äôve already created idx_video_metadata_project_date (üëç). If you notice slow month queries, consider a substr(created_date,1,7) computed column in the future, but current indices should be fine.

Timezone differences: ffprobe dates can be UTC/offset. If you observe off-by-one-day in some locales, normalize date_taken to local date before writing created_* (match what you do for photos).

Quick checklist to implement

 Add fallback created_* in VideoService.index_video() (mtime ‚Üí YYYY-MM-DD).

 Add get_videos_by_date(...) and get_media_by_date(...) in reference_db.py.

 Switch date-node open to db.get_media_by_date(...).

 Add count_media_for_year/month/day(...) and switch sidebar_qt to use them.

 Either stop using branches for date, or populate project_videos alongside project_images.

 Add single_pass_backfill_created_fields_videos() and call it post-scan.
