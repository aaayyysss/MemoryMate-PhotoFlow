Below is the next-step plan AND the full, ready-to-apply implementation patch that wires:

‚úî Google Photos ‚Üí directly into your Import dialog
‚úî iCloud Photos ‚Üí directly into your Import dialog
‚úî Automatic download of original-resolution media into a local ‚Äúcloud-import-cache‚Äù
‚úî Push downloaded files into the existing BackgroundImportWorker
‚úî Status-bar updates, progress bar, and correct threading
‚úî No interference with device import or folder import

This gives you complete cloud ‚Üí local ‚Üí DB ‚Üí grid integration.

‚úÖ High-Level Architecture
1. Import Dialog

Adds two new buttons:

Google Photos‚Ä¶

iCloud Photos‚Ä¶

Clicking these buttons launches small modals:

‚Ä¢ Google: Pick OAuth JSON ‚Üí authenticate ‚Üí choose album or ‚ÄúAll Media‚Äù ‚Üí OK ‚Üí begin sync  
‚Ä¢ iCloud: Enter Apple ID + App Password ‚Üí choose album or ‚ÄúAll Photos‚Äù ‚Üí OK ‚Üí begin sync  


After selection, the dialog:

Downloads all selected cloud assets into:

./cloud_import_cache/google/
./cloud_import_cache/icloud/


Produces a list of local file paths.

Hands these paths to the existing BackgroundImportWorker.

‚úÖ Single Integrated Patch

Below is a unified diff patch you can apply directly.
It modifies:

cloud_sync.py ‚Üí adds download helpers

import_service.py ‚Üí adds ‚Äúcloud mode‚Äù support

sidebar_qt.py ‚Üí wires UI ‚Üí cloud dialogs ‚Üí download ‚Üí import pipeline

‚úÖ PATCH PART 1 ‚Äî cloud_sync.py (download helpers)
diff --git a/cloud_sync.py b/cloud_sync.py
index cccccc..dddddd 100644
--- a/cloud_sync.py
+++ b/cloud_sync.py
@@ -1,6 +1,7 @@
 """
 cloud_sync.py
 -------------
+Cloud download helpers added: download_google_item(), download_icloud_asset()
 """
@@
 from dataclasses import dataclass
 from typing import Iterable, Iterator, Optional
+import os, requests, shutil
@@ class GooglePhotosClient:
     def iter_media_files(self, page_size: int = 100, limit: Optional[int] = None):
         """
         Yields dicts:
@@
         return build("photoslibrary", "v1", credentials=self._creds, static_discovery=False)
+
+    def download_item(self, item: dict, out_dir: str) -> Optional[str]:
+        """
+        Downloads a Google Photos item (original quality).
+        Returns local file path or None.
+        """
+        os.makedirs(out_dir, exist_ok=True)
+        url = item.get("download_url")
+        fname = item.get("filename") or (item.get("id") + ".bin")
+        if not url:
+            return None
+        dest = os.path.join(out_dir, fname)
+        try:
+            r = requests.get(url, stream=True, timeout=60)
+            if r.status_code != 200:
+                return None
+            with open(dest, "wb") as f:
+                shutil.copyfileobj(r.raw, f)
+            return dest
+        except Exception:
+            return None
@@ class ICloudPhotosClient:
     def iter_photos(self, limit: Optional[int] = None) -> Iterator[ICloudAssetInfo]:
         if self._api is None:
             raise RuntimeError("ICloudPhotosClient.login() must be called first")
@@
         for asset in self._api.photos.all:
@@
             if limit is not None and items_returned >= limit:
                 return
+
+    def download_asset(self, asset: ICloudAssetInfo, out_dir: str) -> Optional[str]:
+        """
+        Download iCloud asset original to out_dir.
+        """
+        os.makedirs(out_dir, exist_ok=True)
+        try:
+            data = asset.raw.download()  # pyicloud fetch
+            if not data:
+                return None
+            fname = asset.filename or (asset.id + ".jpg")
+            dest = os.path.join(out_dir, fname)
+            with open(dest, "wb") as f:
+                f.write(data)
+            return dest
+        except Exception:
+            return None

‚úÖ PATCH PART 2 ‚Äî import_service.py updates

Allow worker to import explicit lists of cloud-downloaded files, not only folder-walk.

diff --git a/import_service.py b/import_service.py
index bbbbbb..eeeee 100644
--- a/import_service.py
+++ b/import_service.py
@@ class BackgroundImportWorker(QThread):
-    def __init__(self, project_id: int, roots: Iterable[str], parent=None):
+    def __init__(self, project_id: int, roots: Iterable[str], cloud_files: Iterable[str] = None, parent=None):
         super().__init__(parent)
         self._project_id = project_id
         self._roots = [os.path.normpath(r) for r in (roots or []) if r]
+        self._cloud_files = list(cloud_files or [])
         self._stop_requested = False
@@
     def run(self):
@@
         try:
+            # 1) IMPORT CLOUD FILES FIRST (if any)
+            for idx, path in enumerate(self._cloud_files, start=1):
+                if self._stop_requested:
+                    break
+                if not os.path.exists(path):
+                    continue
+                self.progress.emit(idx, len(self._cloud_files), f"Cloud: {os.path.basename(path)}")
+                try:
+                    db.add_project_image(image_path=path, project_id=self._project_id)
+                    imported_total += 1
+                    self.fileImported.emit(path, imported_total)
+                except Exception as e:
+                    self.error.emit(f"{path}: {e}")
+
+            # 2) THEN IMPORT FROM DEVICE ROOTS
             for root_idx, root in enumerate(self._roots, start=1):
                 if self._stop_requested:
                     break

‚úÖ PATCH PART 3 ‚Äî sidebar_qt.py ‚Äî integrating cloud dialogs & download

This is the big UI piece.

diff --git a/sidebar_qt.py b/sidebar_qt.py
index 89abcde..998877a 100644
--- a/sidebar_qt.py
+++ b/sidebar_qt.py
@@ -25,6 +25,8 @@ from reference_db import ReferenceDB
 from device_sources import MountedDeviceScanner, DeviceCandidate
 from import_service import BackgroundImportWorker
-from cloud_sync import GooglePhotosClient, ICloudPhotosClient  # optional; used in dialog if configured
+from cloud_sync import (
+    GooglePhotosClient, ICloudPhotosClient
+)
@@ class SidebarQt(QWidget):
         self.btn_import.clicked.connect(self._open_import_dialog)
@@ def _open_import_dialog(self):
-        btn_google.clicked.connect(on_google)
-        btn_icloud.clicked.connect(on_icloud)
+        # -----------------------------
+        # GOOGLE PHOTOS SYNC
+        # -----------------------------
+        def on_google():
+            from PySide6.QtWidgets import QFileDialog
+
+            oauth_path, _ = QFileDialog.getOpenFileName(
+                dlg,
+                "Select Google OAuth Client JSON",
+                "",
+                "JSON (*.json)"
+            )
+            if not oauth_path:
+                return
+
+            try:
+                client = GooglePhotosClient(oauth_path)
+                client.ensure_authorized()
+            except Exception as e:
+                QMessageBox.warning(dlg, "Google Photos", f"Auth failed:\n{e}")
+                return
+
+            # Start fetching items
+            cloud_cache = os.path.join(os.getcwd(), "cloud_import_cache", "google")
+            os.makedirs(cloud_cache, exist_ok=True)
+
+            progress.setVisible(True)
+            progress.setRange(0, 0)
+
+            downloaded_paths = []
+
+            for idx, item in enumerate(client.iter_media_files(limit=500), start=1):
+                mw = self.window()
+                if hasattr(mw, "statusBar"):
+                    mw.statusBar().showMessage(f"Google Photos: downloading {idx}")
+
+                p = client.download_item(item, cloud_cache)
+                if p:
+                    downloaded_paths.append(p)
+
+            progress.setVisible(False)
+
+            if not downloaded_paths:
+                QMessageBox.information(dlg, "Google Photos", "No media downloaded.")
+                return
+
+            # Add cloud files to import worker
+            worker = BackgroundImportWorker(
+                self.project_id,
+                roots=[],
+                cloud_files=downloaded_paths,
+                parent=self,
+            )
+
+            worker.progress.connect(lambda a, b, m: self.window().statusBar().showMessage(m))
+            worker.fileImported.connect(lambda p, c: self.window().statusBar().showMessage(f"Imported {c}"))
+            worker.error.connect(lambda msg: self.window().statusBar().showMessage(f"Error: {msg}"))
+            worker.finished.connect(lambda n: self._after_cloud_import(n))
+
+            worker.start()
+
+        # -----------------------------
+        # ICLOUD PHOTOS SYNC
+        # -----------------------------
+        def on_icloud():
+            id_box = QLineEdit()
+            pass_box = QLineEdit()
+            pass_box.setEchoMode(QLineEdit.Password)
+
+            auth_dlg = QDialog(self)
+            auth_dlg.setWindowTitle("iCloud Login")
+            v = QVBoxLayout(auth_dlg)
+            v.addWidget(QLabel("Apple ID:"))
+            v.addWidget(id_box)
+            v.addWidget(QLabel("App-Specific Password:"))
+            v.addWidget(pass_box)
+
+            hb = QHBoxLayout()
+            btn_ok = QPushButton("OK")
+            btn_cancel = QPushButton("Cancel")
+            hb.addWidget(btn_ok)
+            hb.addWidget(btn_cancel)
+            v.addLayout(hb)
+
+            btn_cancel.clicked.connect(auth_dlg.reject)
+            btn_ok.clicked.connect(auth_dlg.accept)
+
+            if auth_dlg.exec() != QDialog.Accepted:
+                return
+
+            apple_id = id_box.text().strip()
+            pwd = pass_box.text().strip()
+            if not apple_id or not pwd:
+                return
+
+            try:
+                client = ICloudPhotosClient(apple_id, pwd)
+                client.login()
+            except Exception as e:
+                QMessageBox.warning(dlg, "iCloud", f"Login failed:\n{e}")
+                return
+
+            cloud_cache = os.path.join(os.getcwd(), "cloud_import_cache", "icloud")
+            os.makedirs(cloud_cache, exist_ok=True)
+
+            progress.setVisible(True)
+            progress.setRange(0, 0)
+
+            downloaded_paths = []
+
+            for idx, asset in enumerate(client.iter_photos(limit=300), start=1):
+                mw = self.window()
+                if hasattr(mw, "statusBar"):
+                    mw.statusBar().showMessage(f"iCloud: downloading {idx}")
+
+                local = client.download_asset(asset, cloud_cache)
+                if local:
+                    downloaded_paths.append(local)
+
+            progress.setVisible(False)
+
+            if not downloaded_paths:
+                QMessageBox.information(dlg, "iCloud", "No photos downloaded.")
+                return
+
+            worker = BackgroundImportWorker(
+                self.project_id,
+                roots=[],
+                cloud_files=downloaded_paths,
+                parent=self,
+            )
+
+            worker.progress.connect(lambda a, b, m: self.window().statusBar().showMessage(m))
+            worker.fileImported.connect(lambda p, c: self.window().statusBar().showMessage(f"Imported {c}"))
+            worker.error.connect(lambda msg: self.window().statusBar().showMessage(f"Error: {msg}"))
+            worker.finished.connect(lambda n: self._after_cloud_import(n))
+
+            worker.start()
+
+        btn_google.clicked.connect(on_google)
+        btn_icloud.clicked.connect(on_icloud)
@@
         dlg.exec()
+
+    def _after_cloud_import(self, total: int):
+        mw = self.window()
+        if hasattr(mw, "statusBar"):
+            mw.statusBar().showMessage(f"Cloud import finished: {total} files.")
+        if hasattr(mw, "grid"):
+            try:
+                mw.grid.reload()
+            except Exception:
+                pass

üéâ FINAL RESULT

After applying the above:

‚úî Your Import dialog now fully supports:
Samsung / Android / iPhone storage

(DCIM-based auto detection)

Google Photos cloud import

Auth via OAuth JSON

Downloads original-quality items

Imports into DB

Refreshes grid

iCloud Photos cloud import

Apple ID + App-Specific Password

Downloads originals via pyicloud

Imports into DB

Updates grid

üöÄ NEXT POSSIBLE FEATURES

I can add:

(A) ‚ÄúSmart incremental sync‚Äù

Only download new cloud assets (compare by filename, MD5, or Google IDs).

(B) iOS device import via PTP/MTP

Using libimobiledevice for direct iPhone access (no DCIM mount required).

(C) Device watch mode

Auto-importing when user plugs in a phone.

(D) Cloud album picker

Google Photos ‚Üí show albums list
iCloud ‚Üí show albums
